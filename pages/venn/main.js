// Generated by CoffeeScript 2.2.1
(function() {
  var ACCEPTED_OPS, ACCEPTED_SETS, FULL_SETS, buttons_elem, calculateSets, error_sign, evalFormula, evalutateField, formula_field, getSetNames, intersection, inverse, makeExprArray, messageDraw, movie, relComp, setOperation, showError, symDiff, union, universe,
    indexOf = [].indexOf;

  buttons_elem = $(".symbol_button");

  formula_field = $("#formula");

  error_sign = $("#error_symbol");

  //Add BonsaiJS to drawing
  movie = bonsai.setup({
    runnerContext: bonsai.IframeRunnerContext
  }).run(document.getElementById("drawing"), {
    url: "venn.js",
    width: 800,
    height: 700
  });

  //default focus to field
  formula_field.focus();

  //Show error symbol in formula formula field
  showError = function(show) {
    return error_sign.css("visibility", (show ? "visible" : "hidden"));
  };

  //Send message to of what to draw to BonsaiJS movie
  //Example: messageDraw([true, false], ["A"])
  messageDraw = function(toggled, labels) {
    var setC;
    setC = Math.log2(toggled.length);
    return movie.sendMessage("draw", {
      "setC": setC,
      "toggled": toggled,
      "labels": labels
    });
  };

  //Set belongings for A, B, C
  FULL_SETS = [[[false, true]], [[false, true, false, true], [false, false, true, true]], [[false, true, false, false, true, true, false, true], [false, false, true, false, true, false, true, true], [false, false, false, true, false, true, true, true]]];

  ACCEPTED_SETS = ["A", "B", "C"];

  //*,(,) and special unicode chats
  ACCEPTED_OPS = ["*", "\u2206", "\u2216", "\u22c3", "\u22c2", "(", ")", "U"];

  getSetNames = function(formula) {
    var c, j, len, ref, setNames;
    setNames = [];
    ref = formula.toUpperCase();
    for (j = 0, len = ref.length; j < len; j++) {
      c = ref[j];
      if (indexOf.call(ACCEPTED_SETS, c) >= 0) {
        if (indexOf.call(setNames, c) < 0) {
          setNames.push(c);
        }
      } else if (indexOf.call(ACCEPTED_OPS, c) < 0) {
        return false;
      }
    }
    //Sort for nice display
    setNames.sort();
    return setNames;
  };

  universe = function(setC) {
    var i;
    return (function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = Math.pow(2, setC); undefined !== 0 && (1 <= ref ? 1 <= j && j <= ref : 1 >= j && j >= ref); i = 1 <= ref ? ++j : --j) {
        results.push(true);
      }
      return results;
    })();
  };

  
  // Set operations

  inverse = function(s) {
    var e;
    return (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = s.length; j < len; j++) {
        e = s[j];
        results.push(!e);
      }
      return results;
    })();
  };

  //Help operation to execute set operation (op) on arrays of subsets
  setOperation = function(s1, s2, op) {
    var i;
    return (function() {
      var j, ref, results;
      results = [];
      for (i = j = 0, ref = s1.length - 1; undefined !== 0 && (0 <= ref ? 0 <= j && j <= ref : 0 >= j && j >= ref); i = 0 <= ref ? ++j : --j) {
        results.push(op(s1[i], s2[i]));
      }
      return results;
    })();
  };

  union = function(e1, e2) {
    return e1 || e2;
  };

  intersection = function(e1, e2) {
    return e1 && e2;
  };

  symDiff = function(e1, e2) {
    return (e1 && !e2) || (!e1 && e2); //XOR
  };

  relComp = function(e1, e2) {
    return e1 && !e2;
  };

  //Takes an array containing only sets and operators
  calculateSets = function(exprArray) {
    var curSet, i, j, op, ref;
    curSet = exprArray[0];
    if (exprArray.length === 1) {
      return curSet;
    }
    for (i = j = 1, ref = exprArray.length - 1; 2 !== 0 && (1 <= ref ? 1 <= j && j <= ref : 1 >= j && j >= ref); i = j += 2) {
      switch (exprArray[i]) {
        case "\u2206":
          op = symDiff;
          break;
        case "\u2216":
          op = relComp;
          break;
        case "\u22c3":
          op = union;
          break;
        case "\u22c2":
          op = intersection;
      }
      curSet = setOperation(curSet, exprArray[i + 1], op);
    }
    return curSet;
  };

  //Transforms string formula to an array of only sets and operators
  makeExprArray = function(formula, labels) {
    var c, exprArray, i, inPars, innerExpr, innerSet, inv, j, k, len, len1, newSet, pars, ref, setC, setN, uniSet, val;
    if (formula === "") {
      throw "formulaError";
    }
    exprArray = [];
    pars = 0;
    inPars = "";
    inv = false;
    ref = formula.toUpperCase();
    for (j = 0, len = ref.length; j < len; j++) {
      c = ref[j];
      if (pars > 0) {
        if (c === "(") {
          pars++;
          inPars = inPars + c;
        } else if (c === ")") {
          pars--;
          if (pars === 0) {
            //end parenthesis section
            innerExpr = makeExprArray(inPars, labels);
            innerSet = calculateSets(innerExpr);
            inPars = "";
            if (inv) {
              exprArray.push(inverse(innerSet));
              inv = false;
            } else {
              exprArray.push(innerSet);
            }
          } else {
            inPars = inPars + c;
          }
        } else {
          inPars = inPars + c;
        }
      } else if (c === "(") {
        pars = 1;
      } else if (c === ")") {
        throw "formulaError";
      } else if (c === "U") {
        uniSet = universe(labels.length);
        if (inv) {
          exprArray.push(inverse(uniSet));
          inv = false;
        } else {
          exprArray.push(uniSet);
        }
      } else if (indexOf.call(ACCEPTED_OPS, c) >= 0) {
        //Is operation
        //Check so no not before
        if (inv) {
          throw "formulaError";
        }
        if (c === "*") {
          inv = true;
        } else {
          exprArray.push(c);
        }
      } else if (indexOf.call(labels, c) >= 0) {
        setN = labels.indexOf(c);
        setC = labels.length;
        newSet = FULL_SETS[setC - 1][setN];
        if (inv) {
          exprArray.push(inverse(newSet));
          inv = false;
        } else {
          exprArray.push(newSet);
        }
      }
    }
    if (inv || (pars > 0) || (exprArray.length % 2 === 0)) {
      throw "formulaError";
    }
//check so no double operator or sets
    for (i = k = 0, len1 = exprArray.length; k < len1; i = ++k) {
      val = exprArray[i];
      if ((i % 2) === 0) {
        //even
        if (typeof val === "string") {
          throw "formulaError";
        }
      } else if (typeof val !== "string") {
        throw "formulaError";
      }
    }
    return exprArray;
  };

  //Actual evaluation
  //of formula field
  evalFormula = function(formula) {
    var drawSet, exprArray, labels;
    showError(false); //reset error syambol
    labels = getSetNames(formula);
    if (!labels) {
      showError(true);
      return;
    }
    try {
      exprArray = makeExprArray(formula, labels);
      drawSet = calculateSets(exprArray);
      showError(false);
      //send draw message
      return messageDraw(drawSet, labels);
    } catch (error) {
      return showError(true);
    }
  };

  evalutateField = function() {
    var formula;
    formula = formula_field.val();
    return evalFormula(formula);
  };

  formula_field.on("keyup", evalutateField);

  //Buttons for inserting special chars
  buttons_elem.click(function() {
    var endSel, newChar, newCursorPos, newVal, oldVal, startSel;
    startSel = formula_field[0].selectionStart;
    endSel = formula_field[0].selectionEnd;
    newChar = $(this).html();
    oldVal = formula_field.val();
    newVal = oldVal.substring(0, startSel) + newChar + oldVal.substring(endSel);
    formula_field.val(newVal);
    formula_field.focus();
    newCursorPos = startSel + 1;
    formula_field[0].selectionStart = newCursorPos;
    formula_field[0].selectionEnd = newCursorPos;
    //reevaluate
    return evalutateField();
  });

  //Run at pageload
  evalutateField();

}).call(this);
