// Generated by CoffeeScript 2.2.1
(function() {
  //Graph interface using BonsaiJS
  var BG_COLOR, EDGE_THICKNESS, Edge, HOVER_COLOR, NODE_COLOR, NODE_RADIUS, Node, PATH_COLOR, SELECTED_COLOR, STATE, STROKE_COLOR, WEIGHT_OFFSET, actionState, bg, clearGraph, clickEdge, clickNode, closeMenu, dragNode, e1, edges, hoverShape, instructionText, makeEdge, makeNode, makingEdgeX, makingEdgeY, n1, n2, newEdgeStart, newPath, nodes, pathNode1, pathNode2, recMessage, removeEdge, removeNode, resetHover, runDijkstra, selectDijkstra, selected, sendMessage, setEdgeWeight, setPathNode, showEdgeMenu, showNodeMenu, startMakingEdge, stopDijkstra, stopHighLight, updateProperties, updateStage;

  NODE_RADIUS = 30;

  EDGE_THICKNESS = 7;

  NODE_COLOR = "#9A9A9A";

  STROKE_COLOR = "black";

  HOVER_COLOR = "#C3C3C3";

  BG_COLOR = "white";

  SELECTED_COLOR = "#fc7f6f";

  PATH_COLOR = "#6ef470";

  WEIGHT_OFFSET = 20;

  STATE = {
    IDLE: 0,
    MAKING_EDGE: 1,
    SELECTING_NODE1: 2,
    SELECTING_NODE2: 3,
    MENU_OPEN: 4,
    DRAGGING_NODE: 5,
    PATH_HIGHLIGHT: 6
  };

  Node = class Node {
    constructor(shape1) {
      this.shape = shape1;
      this.x = this.shape.attr("x");
      this.y = this.shape.attr("y");
      this.edges = [];
      this.shape.node = this;
      this.pathInfo = null;
    }

    setPos(x, y) {
      this.x = x;
      this.y = y;
      this.shape.attr("x", x);
      return this.shape.attr("y", y);
    }

    clearEdges() {
      var e, ed, i, len, ref, results;
      ref = (function() {
        var j, len, ref, results1;
        ref = this.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          ed = ref[j];
          results1.push(ed);
        }
        return results1;
      }).call(this);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        e = ref[i];
        results.push(e.deleteEdge());
      }
      return results;
    }

    removeEdge(e) {
      var remI;
      remI = this.edges.indexOf(e);
      if (remI !== -1) {
        return this.edges.splice(remI, 1);
      }
    }

    getGrade() {
      return this.edges.length;
    }

  };

  Edge = class Edge {
    constructor(n11, n21, path1) {
      this.n1 = n11;
      this.n2 = n21;
      this.path = path1;
      this.n1.edges.push(this);
      this.n2.edges.push(this);
      this.weight = 1;
      this.text = new Text();
    }

    updateEdge() {
      this.path.clear();
      this.path.moveTo(this.n1.x, this.n1.y);
      this.path.lineTo(this.n2.x, this.n2.y);
      this.path.closePath();
      return this.updateWeight();
    }

    updateWeight() {
      var dx, dy, xOffset, yOffset;
      dx = this.n2.x - this.n1.x;
      dy = this.n2.y - this.n1.y;
      xOffset = 0;
      yOffset = 0;
      if (Math.abs(dy) > Math.abs(dx)) {
        xOffset = WEIGHT_OFFSET;
      } else {
        yOffset = WEIGHT_OFFSET;
      }
      this.text.attr("text", this.weight);
      this.text.attr("x", this.n1.x + dx / 2 + xOffset);
      return this.text.attr("y", this.n1.y + dy / 2 + yOffset);
    }

    opposite(node) {
      if (node === this.n1) {
        return this.n2;
      } else {
        return this.n1;
      }
    }

    deleteEdge() {
      this.n1.removeEdge(this);
      this.n2.removeEdge(this);
      return edges.splice(edges.indexOf(this), 1);
    }

    setWeight(newWeight) {
      this.weight = newWeight;
      return this.updateWeight();
    }

  };

  //Parts of graph, State of movie
  nodes = [];

  edges = [];

  selected = null; //Selected shape

  bg = new Rect(0, 0, stage.width, stage.height);

  bg.fill(BG_COLOR);

  instructionText = new Text().attr({
    x: 10,
    y: 10
  });

  actionState = STATE.IDLE;

  newPath = null;

  newEdgeStart = null;

  makingEdgeX = 0; //End position to draw of new edge

  makingEdgeY = 0;

  //pathfinding
  pathNode1 = null;

  pathNode2 = null;

  
  // User Interaction

  dragNode = function(e, node) {
    var edge, i, len, ref;
    if (actionState !== STATE.IDLE && actionState !== STATE.DRAGGING_NODE) {
      return;
    }
    closeMenu();
    hoverShape(node.shape);
    node.setPos(e.x, e.y);
    ref = node.edges;
    for (i = 0, len = ref.length; i < len; i++) {
      edge = ref[i];
      edge.updateEdge();
    }
    return actionState = STATE.DRAGGING_NODE;
  };

  hoverShape = function(shape) {
    switch (actionState) {
      case STATE.DRAGGING_NODE:
      case STATE.MENU_OPEN:
      case STATE.PATH_HIGHLIGHT:
        return;
      case STATE.MAKING_EDGE:
        if (shape.node != null) {
          makingEdgeX = shape.node.x;
          makingEdgeY = shape.node.y;
          updateStage();
        }
    }
    if (selected !== null) {
      selected.stroke(STROKE_COLOR, EDGE_THICKNESS);
    }
    selected = shape;
    return selected.stroke(HOVER_COLOR, EDGE_THICKNESS);
  };

  resetHover = function() {
    if (actionState === STATE.DRAGGING_NODE || actionState === STATE.MENU_OPEN) {
      return;
    }
    if (selected !== null) {
      return selected.stroke(STROKE_COLOR, EDGE_THICKNESS);
    }
  };

  clickNode = function(e, shape) {
    hoverShape(shape);
    switch (actionState) {
      case STATE.IDLE:
        return showNodeMenu(e.x, e.y);
      case STATE.PATH_HIGHLIGHT:
        return stopHighLight();
      case STATE.MENU_OPEN:
        closeMenu();
        return hoverShape(shape);
      case STATE.MAKING_EDGE:
        actionState = STATE.IDLE;
        makeEdge(newEdgeStart, shape.node);
        updateStage();
        return updateProperties();
      case STATE.SELECTING_NODE1:
        setPathNode(shape.node, 1);
        actionState = STATE.SELECTING_NODE2;
        return updateStage();
      case STATE.SELECTING_NODE2:
        setPathNode(shape.node, 2);
        return runDijkstra();
      case STATE.DRAGGING_NODE:
        return actionState = STATE.IDLE;
    }
  };

  clickEdge = function(edge, e) {
    switch (actionState) {
      case STATE.IDLE:
        closeMenu();
        hoverShape(edge.path);
        return showEdgeMenu(e.x, e.y);
      case STATE.MAKING_EDGE:
        actionState = STATE.IDLE;
        return updateStage();
      case STATE.SELECTING_NODE1:
      case STATE.SELECTING_NODE2:
        actionState = STATE.IDLE;
        stopDijkstra();
        return updateStage();
      case STATE.PATH_HIGHLIGHT:
        return stopHighLight();
    }
  };

  showEdgeMenu = function(x, y) {
    actionState = STATE.MENU_OPEN;
    return sendMessage("showEdgeOptions", {
      "x": x,
      "y": y
    });
  };

  showNodeMenu = function(x, y) {
    actionState = STATE.MENU_OPEN;
    return sendMessage("showNodeOptions", {
      "x": x,
      "y": y
    });
  };

  closeMenu = function() {
    sendMessage("hideOptions", []);
    return actionState = STATE.IDLE;
  };

  
  // Event handling for stage

  bg.on("click", function(e) {
    switch (actionState) {
      case STATE.MENU_OPEN:
        closeMenu();
        resetHover();
        break;
      case STATE.IDLE:
        makeNode(e.x, e.y);
        updateProperties();
        break;
      case STATE.MAKING_EDGE:
        actionState = STATE.IDLE;
        break;
      case STATE.SELECTING_NODE1:
      case STATE.SELECTING_NODE2:
        stopDijkstra();
        actionState = STATE.IDLE;
        break;
      case STATE.PATH_HIGHLIGHT:
        stopHighLight();
    }
    return updateStage();
  });

  bg.on("pointermove", function(e) {
    resetHover();
    if (actionState === STATE.MAKING_EDGE) {
      makingEdgeX = e.x;
      makingEdgeY = e.y;
      return updateStage();
    }
  });

  
  // Message passing to DOM

  sendMessage = function(action, data) {
    return stage.sendMessage("action", {
      action: action,
      data: data
    });
  };

  recMessage = function(msg) {
    var action, data;
    action = msg.action;
    data = msg.data;
    switch (action) {
      case "removeNode":
        return removeNode(selected.node);
      case "makeEdge":
        return startMakingEdge();
      case "removeEdge":
        return removeEdge(selected.edge);
      case "setWeight":
        return setEdgeWeight(selected.edge, data);
      case "clearGraph":
        return clearGraph();
      case "startDijkstra":
        return selectDijkstra();
    }
  };

  stage.on("message:action", recMessage);

  updateProperties = function() {
    var costTotal, edgeC, nodeC;
    nodeC = nodes.length;
    edgeC = edges.length;
    costTotal = 0;
    if (edgeC > 0) {
      costTotal = edges.map(function(e) {
        return e.weight;
      }).reduce(function(x, y) {
        return x + y;
      });
    }
    return sendMessage("updateProperties", {
      "nodeC": nodeC,
      "edgeC": edgeC,
      "costTot": costTotal
    });
  };

  
  // Add elelments

  makeNode = function(x, y) {
    var newCir, newNode;
    newCir = new Circle(x, y, NODE_RADIUS);
    newCir.fill(NODE_COLOR).stroke(STROKE_COLOR, EDGE_THICKNESS);
    newNode = new Node(newCir);
    //Events
    newCir.on("drag", function(e) {
      return dragNode(e, newNode);
    });
    newCir.on("pointermove", function(e) {
      return hoverShape(newCir);
    });
    newCir.on("click", function(e) {
      return clickNode(e, newCir);
    });
    nodes.push(newNode);
    hoverShape(newCir);
    return newNode;
  };

  makeEdge = function(n1, n2) {
    var newEdge, path;
    path = new Path();
    path.stroke("black", EDGE_THICKNESS);
    newEdge = new Edge(n1, n2, path);
    newEdge.updateEdge();
    //Events
    path.on("pointermove", function(e) {
      return hoverShape(path);
    });
    path.on("click", function(e) {
      return clickEdge(newEdge, e);
    });
    path.edge = newEdge;
    edges.push(newEdge);
    return newEdge;
  };

  removeNode = function(remNode) {
    remNode.clearEdges();
    nodes.splice(nodes.indexOf(remNode), 1);
    closeMenu();
    updateProperties();
    return updateStage();
  };

  removeEdge = function(remEdge) {
    remEdge.deleteEdge();
    updateProperties();
    updateStage();
    return closeMenu();
  };

  clearGraph = function() {
    nodes = [];
    edges = [];
    actionState = STATE.IDLE;
    closeMenu();
    updateStage();
    return updateProperties();
  };

  setEdgeWeight = function(edge, weight) {
    selected.edge.setWeight(weight);
    closeMenu();
    updateProperties();
    return updateStage();
  };

  updateStage = function() {
    var e, i, j, len, len1, n;
    stage.clear();
    bg.addTo(stage);
    for (i = 0, len = edges.length; i < len; i++) {
      e = edges[i];
      e.path.addTo(stage);
      //Draw weights for each Path
      if (e.weight !== 1) {
        e.text.addTo(stage);
      }
    }
    //Draw edge in the makingEdge
    if (actionState === STATE.MAKING_EDGE) {
      newPath.clear();
      newPath.moveTo(newEdgeStart.x, newEdgeStart.y);
      newPath.lineTo(makingEdgeX, makingEdgeY);
      newPath.closePath();
      newPath.addTo(stage);
    }
    for (j = 0, len1 = nodes.length; j < len1; j++) {
      n = nodes[j];
      n.shape.addTo(stage);
    }
    switch (actionState) {
      case STATE.SELECTING_NODE1:
        instructionText.attr({
          text: "Select start node"
        });
        instructionText.addTo(stage);
        break;
      case STATE.SELECTING_NODE2:
        instructionText.attr({
          text: "Select end node"
        });
        instructionText.addTo(stage);
    }
    return console.log(actionState);
  };

  startMakingEdge = function() {
    closeMenu();
    actionState = STATE.MAKING_EDGE;
    newEdgeStart = selected.node;
    newPath = new Path();
    newPath.stroke("black", EDGE_THICKNESS);
    newPath.on("click", function() {
      actionState = STATE.IDLE;
      return updateStage();
    });
    return newPath.on("pointermove", function(e) {
      makingEdgeX = e.x;
      makingEdgeY = e.y;
      return updateStage();
    });
  };

  stopHighLight = function() {
    var edge, i, len;
    for (i = 0, len = edges.length; i < len; i++) {
      edge = edges[i];
      edge.path.stroke(STROKE_COLOR, EDGE_THICKNESS);
    }
    actionState = STATE.IDLE;
    return stopDijkstra();
  };

  
  // Specific Algorithms

  setPathNode = function(node, n) {
    if (n === 1) {
      pathNode1 = node;
      return node.shape.fill(SELECTED_COLOR);
    } else {
      pathNode2 = node;
      return node.shape.fill(SELECTED_COLOR);
    }
  };

  selectDijkstra = function() {
    closeMenu();
    stopHighLight();
    actionState = STATE.SELECTING_NODE1;
    return updateStage();
  };

  stopDijkstra = function() {
    if (pathNode1 != null) {
      pathNode1.shape.fill(NODE_COLOR);
      pathNode1 = null;
    }
    if (pathNode2 != null) {
      pathNode2.shape.fill(NODE_COLOR);
      pathNode2 = null;
    }
    return updateStage();
  };

  runDijkstra = function() {
    var curNode, edge, i, j, len, len1, neighbor, newCost, nextNodeI, node, nodeQ, pathCost, ref, ref1;
    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      node.pathInfo = {
        cost: 0,
        visited: false,
        qued: false,
        prevEdge: null
      };
    }
    nodeQ = [pathNode1];
    //Find path to node2
    while (!(curNode === pathNode2 || nodeQ.length === 0)) {
      //Get next curNode with lowest cost
      nextNodeI = (function() {
        var results = [];
        for (var j = 0, ref = nodeQ.length - 1; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this).reduce(function(i1, i2) {
        if (nodeQ[i1].pathInfo.cost > nodeQ[i2].pathInfo.cost) {
          return i2;
        } else {
          return i1;
        }
      });
      curNode = nodeQ[nextNodeI];
      nodeQ.splice(nextNodeI, 1);
      curNode.pathInfo.visited = true;
      if (curNode === pathNode2) {
        break;
      }
      ref1 = curNode.edges;
      //Iterate over all edges out from current node
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        neighbor = edge.opposite(curNode);
        if (!neighbor.pathInfo.visited) {
          newCost = curNode.pathInfo.cost + edge.weight;
          if (neighbor.pathInfo.qued) {
            //Shorter path to already qued node found
            if (newCost < neighbor.pathInfo.cost) {
              neighbor.pathInfo.cost = newCost;
              neighbor.pathInfo.prevEdge = edge;
            }
          } else {
            //Node not qued before
            neighbor.pathInfo.cost = newCost;
            neighbor.pathInfo.prevEdge = edge;
            neighbor.pathInfo.qued = true;
            nodeQ.push(neighbor);
          }
        }
      }
    }
    //End node not found
    if (curNode !== pathNode2) {
      stopDijkstra();
      sendMessage("dijkstraDone", "-");
      alert("No path between nodes exists!");
      return;
    }
    //End found, follow path back
    pathCost = curNode.pathInfo.cost;
    while (curNode.pathInfo.prevEdge !== null) {
      curNode.pathInfo.prevEdge.path.stroke(PATH_COLOR, EDGE_THICKNESS);
      curNode = curNode.pathInfo.prevEdge.opposite(curNode);
    }
    actionState = STATE.PATH_HIGHLIGHT;
    resetHover();
    updateStage();
    return sendMessage("dijkstraDone", pathCost);
  };

  // Start Example
  n1 = makeNode(100, 100);

  n2 = makeNode(300, 100);

  e1 = makeEdge(n1, n2);

  updateStage();

  updateProperties();

}).call(this);
